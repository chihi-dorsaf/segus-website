import { Component, OnInit, ViewChild, ElementRef, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { EmployeeService, Employee, EmployeeFilter, CreateEmployeeRequest, UpdateEmployeeRequest } from '../../services/employee.service';
import { AuthService } from '../../services/auth.service';
import { GamificationService, EmployeeStats } from '../../services/gamification.service';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../environments/environment';

@Component({
  selector: 'app-admin-employees',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule],
  templateUrl: './admin-employees.component.html',
  styleUrls: ['./admin-employees.component.css']
})
export class AdminEmployeesComponent implements OnInit {
  @ViewChild('fileInput') fileInput!: ElementRef;

  // Data
  employees: Employee[] = [];
  filteredEmployees: Employee[] = [];
  stats: any = null;
  selectedEmployee: Employee | null = null;
  employeeWorkStats: { [key: number]: any } = {};

  // Getter pour filteredEmployees avec fallback
  get safeFilteredEmployees(): Employee[] {
    return this.filteredEmployees || [];
  }

  // √âtats
  isLoading: boolean = false;
  isSubmitting: boolean = false;
  showForm: boolean = false;
  isEditMode: boolean = false;
  showImportModal: boolean = false;
  showDeleteModal: boolean = false;
  showDetailsModal: boolean = false;
  showObjectivesModal: boolean = false;
  isSubmittingObjectives: boolean = false;
  selectedEmployeeStats: any = null;

  // Filtres
  searchTerm: string = '';
  statusFilter: string = '';
  positionFilter: string = '';
  ordering: string = '-created_at';

  // Formulaires
  employeeForm: FormGroup;
  importForm: FormGroup;
  objectivesForm: FormGroup;

  // Messages
  successMessage: string = '';
  errorMessage: string = '';
  importResult: { imported_count: number; errors: string[] } | null = null;

  constructor(
    private employeeService: EmployeeService,
    private authService: AuthService,
    private router: Router,
    private cdr: ChangeDetectorRef,
    private fb: FormBuilder,
    private http: HttpClient,
    private gamificationService: GamificationService
  ) {
    this.employeeForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      first_name: [''],
      last_name: [''],
      generate_password: [true],
      position: ['', Validators.required],
      phone: [''],
      hire_date: [''],
      birth_date: [''],
      salary: [null]
    });

    this.importForm = this.fb.group({
      file: [null, Validators.required]
    });

    this.objectivesForm = this.fb.group({
      target_subtasks: [200, [Validators.required, Validators.min(1), Validators.max(1000)]],
      target_hours: [8.0, [Validators.required, Validators.min(1), Validators.max(24)]],
      objective_date: ['']
    });
  }

  ngOnInit(): void {
    // Assurer l'authentification avant de charger les donn√©es
    this.checkAuthAndLoadData();
  }

  private checkAuthAndLoadData(): void {
    console.log('üîê [AdminEmployees] V√©rification de l\'authentification...');

    if (!this.authService.isAuthenticated()) {
      console.warn('‚ö†Ô∏è [AdminEmployees] Utilisateur non authentifi√©, redirection vers /login.');
      this.router.navigate(['/login']);
      return;
    }

    console.log('‚úÖ [AdminEmployees] Utilisateur authentifi√©, v√©rification du profil...');

    this.authService.getUserProfile().subscribe({
      next: (user: any) => {
        console.log('üë§ [AdminEmployees] Profil utilisateur:', user);
        if (!this.hasAdminPermissions(user)) {
          console.warn('‚ö†Ô∏è [AdminEmployees] Permissions insuffisantes');
          this.showError('Acc√®s refus√© : Vous devez √™tre administrateur.');
          this.router.navigate(['/dashboard']);
          return;
        }
        console.log('‚úÖ [AdminEmployees] Permissions valid√©es, chargement des donn√©es');
        this.loadAllData();
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur profil:', error);
        if (error.status === 401) {
          console.warn('‚ö†Ô∏è [AdminEmployees] Token expir√© ou invalide, redirection vers /login.');
          this.authService.logout();
          this.router.navigate(['/login']);
        } else {
          console.error('‚ùå [AdminEmployees] Erreur inattendue:', error);
          this.showError('Erreur lors de la v√©rification du profil utilisateur');
        }
      }
    });
  }

  private hasAdminPermissions(user: any): boolean {
    return user.role?.toUpperCase() === 'ADMIN';
  }

  private loadAllData(): void {
    this.isLoading = true;
    this.loadEmployees();
    this.loadStats();
    this.loadEmployeeWorkStats();
  }

  loadEmployees(): void {
    console.log('üîç [AdminEmployees] Chargement des employ√©s');

    const filters: EmployeeFilter = {
      search: this.searchTerm,
      position: this.positionFilter || undefined,
      ordering: this.ordering
    };

    this.employeeService.getEmployees(filters).subscribe({
      next: (response) => {
        console.log('‚úÖ [AdminEmployees] Employ√©s charg√©s:', response);
        const allEmployees = response.results || response;
        
        // Ensure allEmployees is an array before filtering
        if (!Array.isArray(allEmployees)) {
          console.error('ERROR: allEmployees is not an array:', allEmployees);
          this.employees = [];
          this.filteredEmployees = [];
          return;
        }
        
        // Filtrer pour exclure les administrateurs (bas√© sur le r√¥le ou email admin)
        this.employees = allEmployees.filter((employee: Employee) => 
          !employee.email?.includes('admin') && 
          employee.position !== 'Administrateur' &&
          employee.position !== 'Admin'
        );
        this.filteredEmployees = this.employees;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur lors du chargement des employ√©s:', error);
        this.showError('Erreur lors du chargement des employ√©s');
        this.isLoading = false;
        this.cdr.detectChanges();
      }
    });
  }

  loadStats(): void {
    console.log('üìä [AdminEmployees] Chargement des statistiques');

    this.employeeService.getEmployeeStats().subscribe({
      next: (stats: any) => {
        console.log('‚úÖ [AdminEmployees] Statistiques charg√©es');
        this.stats = stats;
        this.cdr.detectChanges();
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur chargement stats:', error);
        if (error.status === 401) {
          console.warn('‚ö†Ô∏è [AdminEmployees] Token expir√© lors du chargement des stats');
          this.authService.logout();
          this.router.navigate(['/login']);
        } else {
          this.showError('Erreur lors du chargement des statistiques');
        }
      }
    });
  }

  // Recherche et filtres
  onSearch(): void {
    console.log('üîç [AdminEmployees] Recherche avec terme:', this.searchTerm);
    this.loadEmployees();
  }

  onFilterChange(): void {
    console.log('‚úÖ [AdminEmployees] Chargement des donn√©es...');
    this.loadEmployees();
    this.loadStats();
    this.loadEmployeeWorkStats();
  }

  clearFilters(): void {
    this.searchTerm = '';
    this.statusFilter = '';
    this.positionFilter = '';
    this.ordering = '-created_at';
    this.loadEmployees();
  }

  // CRUD Operations
  // Gestion des employ√©s
  createEmployee(): void {
    if (this.employeeForm.invalid) {
      this.showError('Veuillez corriger les erreurs dans le formulaire.');
      return;
    }

    this.isSubmitting = true;
    const formData = this.employeeForm.value;

    // Cr√©er l'employ√© directement - le backend g√©n√©rera automatiquement le matricule
    this.submitEmployeeCreation(formData);
  }



  private submitEmployeeCreation(formData: any): void {
    const employeeData: CreateEmployeeRequest = {
      email: formData.email,
      first_name: formData.first_name,
      last_name: formData.last_name,
      generate_password: formData.generate_password === null ? true : formData.generate_password,
      position: formData.position,
      hire_date: formData.hire_date,
      salary: formData.salary
      // L'ID employ√© sera g√©n√©r√© automatiquement par le backend
    };

    this.employeeService.createEmployee(employeeData).subscribe({
      next: (response) => {
        this.isSubmitting = false;
        this.showSuccess(response.message);
        this.closeForm();
        this.loadEmployees();
      },
      error: (error) => {
        this.isSubmitting = false;
        this.showError('Erreur lors de la cr√©ation: ' + error.message);
      }
    });
  }

  updateEmployee(): void {
    if (!this.selectedEmployee || this.employeeForm.invalid) {
      this.showError('Veuillez remplir tous les champs obligatoires');
      return;
    }

    this.isSubmitting = true;
    const employeeData: UpdateEmployeeRequest = this.employeeForm.value;

    console.log(`‚úèÔ∏è [AdminEmployees] Mise √† jour employ√© ${this.selectedEmployee.id}:`, employeeData);

    this.employeeService.updateEmployee(this.selectedEmployee.id, employeeData).subscribe({
      next: (response) => {
        console.log('‚úÖ [AdminEmployees] Employ√© mis √† jour:', response.message);
        this.showSuccess(response.message);
        this.closeForm();
        this.loadEmployees();
        this.loadStats();
        this.isSubmitting = false;
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur mise √† jour:', error);
        this.showError('Erreur lors de la mise √† jour de l\'employ√©');
        this.isSubmitting = false;
      }
    });
  }

  deleteEmployee(employee: Employee): void {
    if (!confirm(`√ätes-vous s√ªr de vouloir supprimer l'employ√© ${employee.full_name} ?`)) {
      return;
    }

    console.log(`üóëÔ∏è [AdminEmployees] Suppression employ√© ${employee.id}`);
    this.isLoading = true;

    this.employeeService.deleteEmployee(employee.id).subscribe({
      next: (response) => {
        console.log('‚úÖ [AdminEmployees] Employ√© supprim√©:', response.message);
        this.showSuccess(response.message || 'Employ√© supprim√© avec succ√®s');
        this.loadEmployees();
        this.loadStats();
        this.isLoading = false;
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur suppression:', error);
        let errorMessage = 'Erreur lors de la suppression de l\'employ√©';
        
        if (error.status === 403) {
          errorMessage = 'Vous n\'avez pas les permissions pour supprimer cet employ√©';
        } else if (error.status === 404) {
          errorMessage = 'Employ√© non trouv√©';
        } else if (error.status === 400 && error.error?.error) {
          errorMessage = error.error.error;
        } else if (error.message) {
          errorMessage = error.message;
        }
        
        this.showError(errorMessage);
        this.isLoading = false;
      }
    });
  }

  // Gestion des statuts
  toggleEmployeeStatus(employee: Employee): void {
    const newStatus = !employee.is_active;
    console.log(`üîÑ [AdminEmployees] Changement statut employ√© ${employee.id} vers ${newStatus ? 'actif' : 'inactif'}`);

    // Mettre √† jour localement d'abord
    employee.is_active = newStatus;

    // Appeler le service pour mettre √† jour le backend
    this.employeeService.updateEmployee(employee.id, { is_active: newStatus }).subscribe({
      next: (response: any) => {
        console.log('‚úÖ [AdminEmployees] Statut chang√©:', response.message);
        this.showSuccess(response.message);
        this.loadEmployees();
        this.loadStats();
      },
      error: (error: any) => {
        console.error('‚ùå [AdminEmployees] Erreur changement statut:', error);
        // Restaurer l'ancien statut en cas d'erreur
        employee.is_active = !newStatus;
        this.showError('Erreur lors du changement de statut');
      }
    });
  }

  // Export/Import
  exportEmployees(): void {
    console.log('üì§ [AdminEmployees] Export des employ√©s');

    this.employeeService.exportEmployees().subscribe({
      next: (blob) => {
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `employees_${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        window.URL.revokeObjectURL(url);
        this.showSuccess('Export r√©alis√© avec succ√®s');
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur export:', error);
        this.showError('Erreur lors de l\'export');
      }
    });
  }

  onFileSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      this.importForm.patchValue({ file });
    }
  }

  importEmployees(): void {
    if (this.importForm.invalid) {
      this.showError('Veuillez s√©lectionner un fichier CSV');
      return;
    }

    const file = this.importForm.get('file')?.value;
    if (!file) {
      this.showError('Aucun fichier s√©lectionn√©');
      return;
    }

    this.isSubmitting = true;
    console.log('üì• [AdminEmployees] Import des employ√©s');

    this.employeeService.importEmployees(file).subscribe({
      next: (result) => {
        console.log('‚úÖ [AdminEmployees] Import termin√©:', result);
        this.importResult = result;
        this.showSuccess(`${result.imported_count} employ√©s import√©s avec succ√®s`);
        this.loadEmployees();
        this.loadStats();
        this.closeImportModal();
        this.isSubmitting = false;
      },
      error: (error) => {
        console.error('‚ùå [AdminEmployees] Erreur import:', error);
        this.showError('Erreur lors de l\'import');
        this.isSubmitting = false;
      }
    });
  }

  // G√©n√©ration de matricule
  generateMatricule(): void {
    console.log('üÜî [AdminEmployees] G√©n√©ration matricule');

    this.employeeService.generateMatricule().subscribe({
      next: (response: any) => {
        console.log('‚úÖ [AdminEmployees] Matricule g√©n√©r√©:', response.matricule);
        this.employeeForm.patchValue({ matricule: response.matricule });
        this.showSuccess('Matricule g√©n√©r√© automatiquement');
      },
      error: (error: any) => {
        console.error('‚ùå [AdminEmployees] Erreur g√©n√©ration matricule:', error);
        this.showError('Erreur lors de la g√©n√©ration du matricule');
      }
    });
  }

  // Gestion des formulaires
  openCreateForm(): void {
    this.isEditMode = false;
    this.selectedEmployee = null;
    this.employeeForm.reset({
      hire_date: new Date().toISOString().split('T')[0]
    });
    this.showForm = true;
  }

  openEditForm(employee: Employee): void {
    this.isEditMode = true;
    this.selectedEmployee = employee;
    this.employeeForm.patchValue({
      email: employee.email || '',
      first_name: employee.user_details?.first_name || '',
      last_name: employee.user_details?.last_name || '',
      generate_password: false, // Ne pas g√©n√©rer de mot de passe lors de l'√©dition
      position: employee.position || '',
      phone: employee.phone || '',
      hire_date: employee.hire_date || '',
      birth_date: employee.birth_date || '',
      salary: employee.salary || null
    });
    this.showForm = true;
  }

  closeForm(): void {
    this.showForm = false;
    this.isEditMode = false;
    this.selectedEmployee = null;
    this.employeeForm.reset();
  }

  openImportModal(): void {
    this.showImportModal = true;
    this.importForm.reset();
    this.importResult = null;
  }

  closeImportModal(): void {
    this.showImportModal = false;
    this.importForm.reset();
    this.importResult = null;
    if (this.fileInput) {
      this.fileInput.nativeElement.value = '';
    }
  }

  openDetailsModal(employee: Employee): void {
    this.selectedEmployee = employee;
    this.showDetailsModal = true;
  }

  closeDetailsModal(): void {
    this.showDetailsModal = false;
    this.selectedEmployee = null;
  }

  // Utilitaires
  getActiveStatusClass(isActive: boolean): string {
    return isActive ? 'status-active' : 'status-inactive';
  }

  getActiveStatusLabel(isActive: boolean): string {
    return isActive ? 'Actif' : 'Inactif';
  }

  getInitials(employee: Employee): string {
    if (employee.user_details && employee.user_details.first_name && employee.user_details.last_name) {
      return (employee.user_details.first_name.charAt(0) + employee.user_details.last_name.charAt(0)).toUpperCase();
    } else if (employee.user_details && employee.user_details.username) {
      return employee.user_details.username.substring(0, 2).toUpperCase();
    } else if (employee.matricule) {
      return employee.matricule.substring(0, 2).toUpperCase();
    }
    return '??';
  }

  formatDate(date: string): string {
    return new Date(date).toLocaleDateString('fr-FR');
  }

  formatSalary(salary: number | null | undefined): string {
    if (salary === null || salary === undefined) return 'Non d√©fini';
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: 'TND'
    }).format(salary);
  }

  // Messages
  showSuccess(message: string): void {
    this.successMessage = message;
    this.errorMessage = '';
    setTimeout(() => {
      this.successMessage = '';
    }, 5000);
  }

  showError(message: string): void {
    this.errorMessage = message;
    this.successMessage = '';
    setTimeout(() => {
      this.errorMessage = '';
    }, 5000);
  }

  // Tracking pour ngFor
  trackByEmployeeId(index: number, employee: Employee): number {
    return employee.id;
  }

  // M√©thodes pour les statistiques de travail
  getEmployeeWorkStats(employee: Employee): any {
    return this.employeeWorkStats[employee.id] || null;
  }

  getDailyProgressPercentage(employee: Employee): number {
    const stats = this.getEmployeeWorkStats(employee);
    if (!stats || !stats.total_hours_today) return 0;
    return Math.min((stats.total_hours_today / 8) * 100, 100);
  }

  getSessionStatusClass(employee: Employee): string {
    const stats = this.getEmployeeWorkStats(employee);
    const status = stats?.current_session_status || 'none';
    
    switch (status) {
      case 'active': return 'session-active';
      case 'paused': return 'session-paused';
      default: return 'session-none';
    }
  }

  getSessionStatusIcon(employee: Employee): string {
    const stats = this.getEmployeeWorkStats(employee);
    const status = stats?.current_session_status || 'none';
    
    switch (status) {
      case 'active': return 'fa-play-circle';
      case 'paused': return 'fa-pause-circle';
      default: return 'fa-stop-circle';
    }
  }

  getSessionStatusLabel(employee: Employee): string {
    const stats = this.getEmployeeWorkStats(employee);
    const status = stats?.current_session_status || 'none';
    
    switch (status) {
      case 'active': return 'En cours';
      case 'paused': return 'En pause';
      default: return 'Arr√™t√©e';
    }
  }

  // Charger les statistiques de travail pour tous les employ√©s
  loadEmployeeWorkStats(): void {
    // D√©sactiver temporairement le chargement des stats de travail
    // car l'endpoint n'existe pas encore dans le backend
    console.log('‚ö†Ô∏è [AdminEmployees] Chargement des stats de travail d√©sactiv√© temporairement');
  }

  // === M√âTHODES POUR LA GESTION DES OBJECTIFS DE GAMIFICATION ===

  openObjectivesModal(employee: Employee): void {
    this.selectedEmployee = employee;
    this.showObjectivesModal = true;
    
    // Charger les statistiques de gamification de l'employ√©
    this.loadEmployeeGamificationStats(employee);
    
    // R√©initialiser le formulaire avec les valeurs par d√©faut
    this.objectivesForm.patchValue({
      target_subtasks: 200,
      target_hours: 8.0,
      objective_date: ''
    });
  }

  closeObjectivesModal(): void {
    this.showObjectivesModal = false;
    this.selectedEmployee = null;
    this.selectedEmployeeStats = null;
    this.isSubmittingObjectives = false;
  }

  loadEmployeeGamificationStats(employee: Employee): void {
    // Charger les vraies statistiques de gamification depuis l'API
    this.gamificationService.getEmployeeStats({ employee: employee.id }).subscribe({
      next: (stats: EmployeeStats[]) => {
        if (stats && stats.length > 0) {
          const employeeStats = stats[0];
          this.selectedEmployeeStats = {
            total_stars: employeeStats.total_stars,
            total_points: employeeStats.total_points,
            current_level: employeeStats.current_level,
            total_badges: employeeStats.total_badges
          };
        } else {
          // Stats par d√©faut si l'employ√© n'a pas encore de donn√©es
          this.selectedEmployeeStats = {
            total_stars: 0,
            total_points: 0,
            current_level: 'D√©butant',
            total_badges: 0
          };
        }
        console.log(`üìä Stats charg√©es pour ${employee.full_name}:`, this.selectedEmployeeStats);
      },
      error: (error: any) => {
        console.error('Erreur lors du chargement des stats:', error);
        // Stats par d√©faut en cas d'erreur
        this.selectedEmployeeStats = {
          total_stars: 0,
          total_points: 0,
          current_level: 'D√©butant',
          total_badges: 0
        };
      }
    });
  }

  saveObjectives(): void {
    if (this.objectivesForm.invalid || !this.selectedEmployee) {
      return;
    }

    this.isSubmittingObjectives = true;
    const formData = this.objectivesForm.value;
    
    // Pr√©parer les donn√©es pour l'API
    const objectiveData = {
      employee: this.selectedEmployee.id,
      target_subtasks: formData.target_subtasks,
      target_hours: formData.target_hours,
      date: formData.objective_date || new Date().toISOString().split('T')[0]
    };

    console.log('üíæ Sauvegarde des objectifs:', objectiveData);

    // Appel √† la vraie API de gamification
    this.gamificationService.createDailyObjective(objectiveData).subscribe({
      next: (response) => {
        this.successMessage = `Objectifs d√©finis avec succ√®s pour ${this.selectedEmployee?.full_name}: ${formData.target_subtasks} sous-t√¢ches, ${formData.target_hours}h par jour`;
        this.isSubmittingObjectives = false;
        this.closeObjectivesModal();
        
        console.log('‚úÖ Objectifs sauvegard√©s:', response);
        
        // Effacer le message apr√®s 5 secondes
        setTimeout(() => {
          this.successMessage = '';
        }, 5000);
      },
      error: (error: any) => {
        console.error('‚ùå Erreur lors de la sauvegarde des objectifs:', error);
        this.errorMessage = 'Erreur lors de la sauvegarde des objectifs. Veuillez r√©essayer.';
        this.isSubmittingObjectives = false;
        
        // Effacer le message d'erreur apr√®s 5 secondes
        setTimeout(() => {
          this.errorMessage = '';
        }, 5000);
      }
    });
  }
}

